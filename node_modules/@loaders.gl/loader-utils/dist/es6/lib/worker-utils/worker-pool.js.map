{"version":3,"sources":["../../../../src/lib/worker-utils/worker-pool.js"],"names":["WorkerThread","WorkerPool","constructor","source","name","maxConcurrency","onMessage","onDebug","reuseWorkers","jobQueue","idleQueue","count","isDestroyed","destroy","forEach","worker","process","data","jobName","Promise","resolve","reject","push","_startQueuedJob","length","_getAvailableWorker","job","shift","message","backlog","error","_onWorkerDone","toLowerCase"],"mappings":"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","sourcesContent":["import WorkerThread from './worker-thread';\n\n/**\n * Process multiple data messages with small pool of identical workers\n */\nexport default class WorkerPool {\n  constructor({\n    source,\n    name = 'unnamed',\n    maxConcurrency = 1,\n    onMessage,\n    onDebug = () => {},\n    reuseWorkers = true\n  }) {\n    this.source = source;\n    this.name = name;\n    this.maxConcurrency = maxConcurrency;\n    this.onMessage = onMessage;\n    this.onDebug = onDebug;\n\n    this.jobQueue = [];\n    this.idleQueue = [];\n    this.count = 0;\n    this.isDestroyed = false;\n    this.reuseWorkers = reuseWorkers;\n  }\n\n  destroy() {\n    // Destroy idle workers, active Workers will be destroyed on completion\n    this.idleQueue.forEach(worker => worker.destroy());\n    this.isDestroyed = true;\n  }\n\n  /**\n   * Process binary data in a worker\n   */\n  process(data, jobName) {\n    return new Promise((resolve, reject) => {\n      this.jobQueue.push({data, jobName, resolve, reject});\n      this._startQueuedJob();\n    });\n  }\n\n  // PRIVATE\n\n  async _startQueuedJob() {\n    if (!this.jobQueue.length) {\n      return;\n    }\n    const worker = this._getAvailableWorker();\n    if (!worker) {\n      return;\n    }\n\n    // We have a worker, dequeue and start the job\n    const job = this.jobQueue.shift();\n\n    // @ts-ignore\n    this.onDebug({\n      message: 'processing',\n      worker: worker.name,\n      job: job.jobName,\n      backlog: this.jobQueue.length\n    });\n\n    try {\n      job.resolve(await worker.process(job.data));\n    } catch (error) {\n      job.reject(error);\n    } finally {\n      this._onWorkerDone(worker);\n    }\n  }\n\n  _onWorkerDone(worker) {\n    if (this.isDestroyed) {\n      worker.destroy();\n      return;\n    }\n\n    if (this.reuseWorkers) {\n      this.idleQueue.push(worker);\n    } else {\n      worker.destroy();\n      this.count--;\n    }\n\n    this._startQueuedJob();\n  }\n\n  _getAvailableWorker() {\n    // If a worker has completed and returned to the queue, it can be used\n    if (this.idleQueue.length > 0) {\n      return this.idleQueue.shift();\n    }\n\n    // Create fresh worker if we haven't yet created the max amount of worker threads for this worker source\n    if (this.count < this.maxConcurrency) {\n      this.count++;\n      const name = `${this.name.toLowerCase()} (#${this.count} of ${this.maxConcurrency})`;\n      return new WorkerThread({source: this.source, onMessage: this.onMessage, name});\n    }\n\n    // No worker available, have to wait\n    return null;\n  }\n}\n"],"file":"worker-pool.js"}