import _defineProperty from "@babel/runtime/helpers/esm/defineProperty";

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

import { getDefaultCredentials, getMapsVersion } from '../config';
const DEFAULT_USER_COMPONENT_IN_URL = '{user}';
const DEFAULT_REGION_COMPONENT_IN_URL = '{region}';
export const MAP_TYPES = {
  SQL: 'sql',
  TABLE: 'table',
  TILESET: 'tileset'
};
export const CONNECTIONS = {
  BIGQUERY: 'bigquery',
  CARTO: 'carto'
};
export async function getTileJSON({
  connection,
  type,
  source,
  mapConfig,
  credentials
}) {
  const creds = _objectSpread(_objectSpread({}, getDefaultCredentials()), credentials);

  let url;

  switch (getMapsVersion(creds)) {
    case 'v1':
      url = buildURL({
        mapConfig,
        credentials: creds
      });
      const layergroup = await request({
        url,
        credentials: creds
      });
      return layergroup.metadata.tilejson.vector;

    case 'v2':
      url = buildURL({
        connection,
        type,
        source,
        credentials: creds
      });
      return await request({
        url,
        credentials: creds
      });

    default:
      throw new Error('Invalid maps API version. It shoud be v1 or v2');
  }
}

async function request({
  url,
  credentials
}) {
  let response;

  try {
    response = await fetch(url, {
      headers: {
        Accept: 'application/json'
      }
    });
  } catch (error) {
    throw new Error("Failed to connect to Maps API: ".concat(error));
  }

  const json = await response.json();

  if (!response.ok) {
    dealWithError({
      response,
      json,
      credentials
    });
  }

  return json;
}

function dealWithError({
  response,
  json,
  credentials
}) {
  switch (response.status) {
    case 401:
      throw new Error("Unauthorized access to Maps API: invalid combination of user ('".concat(credentials.username, "') and apiKey ('").concat(credentials.apiKey, "')"));

    case 403:
      throw new Error("Unauthorized access to dataset: the provided apiKey('".concat(credentials.apiKey, "') doesn't provide access to the requested data"));

    default:
      const e = getMapsVersion() === 'v1' ? JSON.stringify(json.errors) : json.error;
      throw new Error(e);
  }
}

function buildURL({
  connection,
  type,
  source,
  mapConfig,
  credentials
}) {
  const encodedApiKey = encodeParameter('api_key', credentials.apiKey);
  const encodedClient = encodeParameter('client', "deck-gl-carto");
  const parameters = [encodedApiKey, encodedClient];

  if (mapConfig) {
    const cfg = JSON.stringify(mapConfig);
    return "".concat(mapsUrl(credentials), "?").concat(parameters.join('&'), "&").concat(encodeParameter('config', cfg));
  }

  let url = "".concat(mapsUrl(credentials), "/").concat(connection, "/").concat(type, "?");
  url += "".concat(encodeParameter('source', source), "&format=tilejson&").concat(parameters.join('&'));
  return url;
}

function mapsUrl(credentials) {
  return credentials.mapsUrl.replace(DEFAULT_USER_COMPONENT_IN_URL, credentials.username).replace(DEFAULT_REGION_COMPONENT_IN_URL, credentials.region);
}

function encodeParameter(name, value) {
  return "".concat(name, "=").concat(encodeURIComponent(value));
}
//# sourceMappingURL=maps-api-client.js.map