{"version":3,"sources":["../../../src/text-layer/utils.js"],"names":["MISSING_CHAR_WIDTH","SINGLE_LINE","nextPowOfTwo","number","Math","pow","ceil","log2","buildMapping","characterSet","getFontWidth","fontHeight","buffer","maxCanvasWidth","mapping","xOffset","yOffset","row","x","i","char","width","y","height","rowHeight","canvasHeight","getTextWidth","text","startIndex","endIndex","character","frameWidth","frame","breakAll","maxWidth","iconMapping","target","rowStartCharIndex","rowOffsetLeft","textWidth","push","breakWord","groupStartCharIndex","groupEndCharIndex","groupWidth","length","autoWrapping","wordBreak","undefined","result","transformRow","line","leftOffsets","rowSize","log","warn","codePointAt","transformParagraph","paragraph","lineHeight","Array","from","numCharacters","rowWidth","autoWrappingEnabled","isFinite","size","rowOffsetTop","lineStartIndex","lineEndIndex","rows","rowIndex","rowStart","rowEnd","j","max","getTextFromBuffer","value","stride","offset","startIndices","bytesPerElement","BYTES_PER_ELEMENT","elementStride","elementOffset","characterCount","floor","texts","codes","constructor","index","String","fromCodePoint","apply","subarray"],"mappings":"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","sourcesContent":["/* eslint-disable max-statements, max-params, complexity, max-depth */\n// TODO merge with icon-layer/icon-manager\nimport {log} from '@deck.gl/core';\n\nconst MISSING_CHAR_WIDTH = 32;\nconst SINGLE_LINE = [];\n\nexport function nextPowOfTwo(number) {\n  return Math.pow(2, Math.ceil(Math.log2(number)));\n}\n\n/**\n * Generate character mapping table or update from an existing mapping table\n * @param characterSet {Array|Set} new characters\n * @param getFontWidth {Function} function to get width of each character\n * @param fontHeight {Number} height of font\n * @param buffer {Number} buffer surround each character\n * @param maxCanvasWidth {Number} max width of font atlas\n * @param mapping {Object} old mapping table\n * @param xOffset {Number} x position of last character in old mapping table\n * @param yOffset {Number} y position of last character in old mapping table\n * @returns {{\n *   mapping: Object,\n *   xOffset: Number, x position of last character\n *   yOffset: Number, y position of last character in old mapping table\n *   canvasHeight: Number, height of the font atlas canvas, power of 2\n *  }}\n */\nexport function buildMapping({\n  characterSet,\n  getFontWidth,\n  fontHeight,\n  buffer,\n  maxCanvasWidth,\n  mapping = {},\n  xOffset = 0,\n  yOffset = 0\n}) {\n  let row = 0;\n  // continue from x position of last character in the old mapping\n  let x = xOffset;\n\n  let i = 0;\n  for (const char of characterSet) {\n    if (!mapping[char]) {\n      // measure texts\n      // TODO - use Advanced text metrics when they are adopted:\n      // https://developer.mozilla.org/en-US/docs/Web/API/TextMetrics\n      const width = getFontWidth(char, i++);\n\n      if (x + width + buffer * 2 > maxCanvasWidth) {\n        x = 0;\n        row++;\n      }\n      mapping[char] = {\n        x: x + buffer,\n        y: yOffset + row * (fontHeight + buffer * 2) + buffer,\n        width,\n        height: fontHeight\n      };\n      x += width + buffer * 2;\n    }\n  }\n\n  const rowHeight = fontHeight + buffer * 2;\n\n  return {\n    mapping,\n    xOffset: x,\n    yOffset: yOffset + row * rowHeight,\n    canvasHeight: nextPowOfTwo(yOffset + (row + 1) * rowHeight)\n  };\n}\n\nfunction getTextWidth(text, startIndex, endIndex, mapping) {\n  let width = 0;\n  for (let i = startIndex; i < endIndex; i++) {\n    const character = text[i];\n    let frameWidth = null;\n    const frame = mapping && mapping[character];\n    if (frame) {\n      frameWidth = frame.width;\n    }\n\n    width += frameWidth;\n  }\n\n  return width;\n}\n\nfunction breakAll(text, startIndex, endIndex, maxWidth, iconMapping, target) {\n  let rowStartCharIndex = startIndex;\n  let rowOffsetLeft = 0;\n\n  for (let i = startIndex; i < endIndex; i++) {\n    // 2. figure out where to break lines\n    const textWidth = getTextWidth(text, i, i + 1, iconMapping);\n    if (rowOffsetLeft + textWidth > maxWidth) {\n      if (rowStartCharIndex < i) {\n        target.push(i);\n      }\n      rowStartCharIndex = i;\n      rowOffsetLeft = 0;\n    }\n    rowOffsetLeft += textWidth;\n  }\n\n  return rowOffsetLeft;\n}\n\nfunction breakWord(text, startIndex, endIndex, maxWidth, iconMapping, target) {\n  let rowStartCharIndex = startIndex;\n  let groupStartCharIndex = startIndex;\n  let groupEndCharIndex = startIndex;\n  let rowOffsetLeft = 0;\n\n  for (let i = startIndex; i < endIndex; i++) {\n    // 1. break text into word groups\n    //  - if current char is white space\n    //  - else if next char is white space\n    //  - else if reach last char\n    if (text[i] === ' ') {\n      groupEndCharIndex = i + 1;\n    } else if (text[i + 1] === ' ' || i + 1 === endIndex) {\n      groupEndCharIndex = i + 1;\n    }\n\n    if (groupEndCharIndex > groupStartCharIndex) {\n      // 2. break text into next row at maxWidth\n      let groupWidth = getTextWidth(text, groupStartCharIndex, groupEndCharIndex, iconMapping);\n      if (rowOffsetLeft + groupWidth > maxWidth) {\n        if (rowStartCharIndex < groupStartCharIndex) {\n          target.push(groupStartCharIndex);\n          rowStartCharIndex = groupStartCharIndex;\n          rowOffsetLeft = 0;\n        }\n\n        // if a single text group is bigger than maxWidth, then `break-all`\n        if (groupWidth > maxWidth) {\n          groupWidth = breakAll(\n            text,\n            groupStartCharIndex,\n            groupEndCharIndex,\n            maxWidth,\n            iconMapping,\n            target\n          );\n          // move reference to last row\n          rowStartCharIndex = target[target.length - 1];\n        }\n      }\n      groupStartCharIndex = groupEndCharIndex;\n      rowOffsetLeft += groupWidth;\n    }\n  }\n\n  return rowOffsetLeft;\n}\n\n// Returns a list of indices where line breaks should be inserted\nexport function autoWrapping(text, wordBreak, maxWidth, iconMapping, startIndex = 0, endIndex) {\n  if (endIndex === undefined) {\n    endIndex = text.length;\n  }\n  const result = [];\n  if (wordBreak === 'break-all') {\n    breakAll(text, startIndex, endIndex, maxWidth, iconMapping, result);\n  } else {\n    breakWord(text, startIndex, endIndex, maxWidth, iconMapping, result);\n  }\n  return result;\n}\n\nfunction transformRow(line, startIndex, endIndex, iconMapping, leftOffsets, rowSize) {\n  let x = 0;\n  let rowHeight = 0;\n\n  for (let i = startIndex; i < endIndex; i++) {\n    const character = line[i];\n    const frame = iconMapping[character];\n    if (frame) {\n      if (!rowHeight) {\n        // frame.height should be a constant\n        rowHeight = frame.height;\n      }\n      leftOffsets[i] = x + frame.width / 2;\n      x += frame.width;\n    } else {\n      log.warn(`Missing character: ${character} (${character.codePointAt(0)})`)();\n      leftOffsets[i] = x;\n      x += MISSING_CHAR_WIDTH;\n    }\n  }\n\n  rowSize[0] = x;\n  rowSize[1] = rowHeight;\n}\n\n/**\n * Transform a text paragraph to an array of characters, each character contains\n * @param paragraph: {String}\n * @param iconMapping {Object} character mapping table for retrieving a character from font atlas\n * @param lineHeight {Number} css line-height\n * @param wordBreak {String} css word-break option\n * @param maxWidth {number} css max-width\n * @param transformedData {Array} output transformed data array, each datum contains\n *   - text: character\n *   - index: character index in the paragraph\n *   - x: x offset in the row,\n *   - y: y offset in the paragraph\n *   - size: [width, height] size of the paragraph\n *   - rowSize: [rowWidth, rowHeight] size of the row\n *   - len: length of the paragraph\n */\nexport function transformParagraph(paragraph, lineHeight, wordBreak, maxWidth, iconMapping) {\n  // Break into an array of characters\n  // When dealing with double-length unicode characters, `str.length` or `str[i]` do not work\n  paragraph = Array.from(paragraph);\n  const numCharacters = paragraph.length;\n  const x = new Array(numCharacters);\n  const y = new Array(numCharacters);\n  const rowWidth = new Array(numCharacters);\n  const autoWrappingEnabled =\n    (wordBreak === 'break-word' || wordBreak === 'break-all') && isFinite(maxWidth) && maxWidth > 0;\n\n  // maxWidth and height of the paragraph\n  const size = [0, 0];\n  const rowSize = [];\n  let rowOffsetTop = 0;\n  let lineStartIndex = 0;\n  let lineEndIndex = 0;\n\n  for (let i = 0; i <= numCharacters; i++) {\n    const char = paragraph[i];\n    if (char === '\\n' || i === numCharacters) {\n      lineEndIndex = i;\n    }\n\n    if (lineEndIndex > lineStartIndex) {\n      const rows = autoWrappingEnabled\n        ? autoWrapping(paragraph, wordBreak, maxWidth, iconMapping, lineStartIndex, lineEndIndex)\n        : SINGLE_LINE;\n\n      for (let rowIndex = 0; rowIndex <= rows.length; rowIndex++) {\n        const rowStart = rowIndex === 0 ? lineStartIndex : rows[rowIndex - 1];\n        const rowEnd = rowIndex < rows.length ? rows[rowIndex] : lineEndIndex;\n        transformRow(paragraph, rowStart, rowEnd, iconMapping, x, rowSize);\n        for (let j = rowStart; j < rowEnd; j++) {\n          y[j] = rowOffsetTop + rowSize[1] / 2;\n          rowWidth[j] = rowSize[0];\n        }\n\n        rowOffsetTop = rowOffsetTop + rowSize[1] * lineHeight;\n        size[0] = autoWrappingEnabled ? maxWidth : Math.max(size[0], rowSize[0]);\n      }\n      lineStartIndex = lineEndIndex;\n    }\n\n    if (char === '\\n') {\n      // Make sure result.length matches paragraph.length\n      x[lineStartIndex] = 0;\n      y[lineStartIndex] = 0;\n      rowWidth[lineStartIndex] = 0;\n      lineStartIndex++;\n    }\n  }\n\n  // last row\n  size[1] = rowOffsetTop;\n  return {x, y, rowWidth, size};\n}\n\nexport function getTextFromBuffer({value, length, stride, offset, startIndices}) {\n  const bytesPerElement = value.BYTES_PER_ELEMENT;\n  const elementStride = stride ? stride / bytesPerElement : 1;\n  const elementOffset = offset ? offset / bytesPerElement : 0;\n  const characterCount =\n    startIndices[length] ||\n    Math.floor((value.length - elementOffset - bytesPerElement) / elementStride) + 1;\n\n  const texts = new Array(length);\n\n  let codes = value;\n  if (elementStride > 1 || elementOffset > 0) {\n    codes = new value.constructor(characterCount);\n    for (let i = 0; i < characterCount; i++) {\n      codes[i] = value[i * elementStride + elementOffset];\n    }\n  }\n\n  for (let index = 0; index < length; index++) {\n    const startIndex = startIndices[index];\n    const endIndex = startIndices[index + 1] || characterCount;\n    texts[index] = String.fromCodePoint.apply(null, codes.subarray(startIndex, endIndex));\n  }\n\n  return {texts, characterCount};\n}\n"],"file":"utils.js"}